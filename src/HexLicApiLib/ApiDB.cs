using CsvHelper;
using Intergraph.PPM.Analytics.Model.Entities;
using Intergraph.PPM.Licensing.Data.Model.KeyGenerationModels;
using Intergraph.PPM.Licensing.Data.Model.KeystoreModels;
using Intergraph.PPM.Licensing.Data.Model.SplmServerModels;
using Intergraph.PPM.Licensing.Portal.Api;
using Intergraph.PPM.Licensing.Portal.Model.Analytics;
using Intergraph.PPM.Licensing.Portal.Model.RawUsageModels;
using Intergraph.PPM.LicensingServerModel;
using LicCommonLib;
using Microsoft.EntityFrameworkCore;
using Microsoft.OData.Client;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Net;
using System.Threading.Tasks;

namespace HexLicApiLib
{
    /// <summary>
    /// Application class to make call to the API 
    /// using the auto-generated OData proxy client.
    /// </summary>
    public class ApiDB
    {
        private readonly ApiConfig _cfg;
        private readonly TokenService _ts;
        private readonly PortalApiContext _ctx;

        /// <summary>
        /// </summary>
        /// <param name="apiClient">The OData proxy client auto-generated by the tooling</param>
        /// <param name="ts">Manage access token required to call the web service API</param>
        public ApiDB(ApiConfig cfg, TokenService ts, PortalApiContext apiClient)
        {
            _cfg = cfg;
            _ts = ts;
            _ctx = apiClient;
        }

        protected ApiConfig Config => this._cfg;

        #region ISL, Live Usage

        /// <summary>
        /// Convenience method
        /// </summary>
        public Task<List<LiveUsage>> GetCompanyLicenseUsage() =>
            GetCompanyLicenseUsage(out var uri);

        /// <summary>
        /// Get the current license usage then parse the data to
        /// extract useful information.
        /// </summary>
        /// <returns>Current license usage</returns>
        public Task<List<LiveUsage>> GetCompanyLicenseUsage(out Uri url)
        {
            var lst = new List<LiveUsage>();
            var wsc = _ctx.Servers.CompanyLicenseUsage(Config.CompanyCode);
            url = wsc.RequestUri;
            return wsc.GetValueAsync().ContinueWith(t =>
            {
                CompanyLicenseUsageResponse_1OfByUserServerLicenseUsageRecord resp = t.Result;
                Collection<ServerLicenseUsageRequestFailure> failures = resp.requestFailures;
                int recordCount = resp.recordCount;

                Collection<ByUserServerLicenseUsageRecord> records = resp.records;
                foreach (ByUserServerLicenseUsageRecord r in records)
                {
                    // convert to custom data object
                    var s = (ServerLicenseUsageRecord)r;
                    var ur = new LiveUsage
                    {
                        LogRecordId = s.id,
                        KeyStoreName = s.keystoreName,
                        ProductTag = s.productTag,
                        ProductName = s.productName,
                        ProductVersion = s.productVersion,
                        Quantity = s.quantity,
                        Status = s.status,
                        LicenseType = s.licenseType,
                        PurchaseType = s.purchaseType,
                        ProjectName = ParseNA(s.projectName),

                        DateAcquired = ParseDT(r.dateAcquired),
                        MinutesAvailable = ParseNum(r.minutesAvailable),
                        MinutesRemaining = ParseNum(r.minutesRemaining),
                        Duration = ParseNum(r.duration),

                        KeyExpiration = ParseDT(r.keyExpiration),
                        CurrentExpiration = ParseDT(r.currentExpiration),
                        CurrentReset = ParseDT(r.currentReset),

                        UserName = ParseNA(r.username),
                        UserNameDecrypted = ParseNA(r.usernameDecrypted),
                        LoginName = ParseNA(r.loginName),
                        LoginNameDecrypted = ParseNA(r.loginNameDecrypted),
                        RemoteUserName = ParseNA(r.remoteUsername),
                        RemoteMachineNameDecrypted = ParseNA(r.remoteMachineNameDecrypted),

                        MachineName = ParseNA(r.machineName),
                        MachineNameDecrypted = ParseNA(r.machineNameDecrypted),
                        RemoteMachineName = ParseNA(r.remoteMachineName),
                        RemoteUserNameDecrypted = ParseNA(r.remoteMachineNameDecrypted),
                        DeviceName = ParseNA(r.deviceName),
                        DeviceNameDecrypted = ParseNA(r.deviceNameDecrypted),

                        IPAddress = ParseNA(r.ipAddress),
                        IPAddressInternal = ParseNA(r.ipAddressInternal),
                        IPAddressExternal = ParseNA(r.ipAddressExternal),

                        CloudLocation = r.cloudLocation,
                        CloudLocationId = r.cloudLocationId
                    };

                    lst.Add(ur);
                }
                return lst;
            });
        }

        #endregion

        #region ISL, Log Usage

        /// <summary>
        /// Download the log usages and save the data to a local file
        /// </summary>
        /// <param name="uri">Web url to log resource</param>
        public Task SaveFile(Uri uri, string fileName)
        {
            var wc = GetWebClient();
            return wc.DownloadFileTaskAsync(uri, fileName);
        }

        /// <summary>
        /// Download the log usage data from the given web url
        /// then parse the data to a data object.
        /// </summary>
        /// <param name="uri">Web url to the web service</param>
        /// <returns>A list of log usage record</returns>
        public Task<List<LogUsage>> ParseAvailableRawUsageFiles(Uri uri) =>
            GetWebClient()
                .OpenReadTaskAsync(uri)
                .ContinueWith(t =>
                {
                    var s = t.Result;
                    using (var sr = new StreamReader(s))
                    using (var csv = new CsvReader(sr, CultureInfo.InvariantCulture))
                    {
                        csv.Configuration.RegisterClassMap<RawUsageMap>();
                        var lst = csv.GetRecords<LogUsage>().ToList();
                        return lst;
                    }
                });

        /// <summary>
        /// Parse the data from the log file into data object. 
        /// </summary>
        /// <param name="fileName">Log usage file</param>
        /// <returns>Log usage data objects</returns>
        public List<LogUsage> ParseAvailableRawUsageFiles(string fileName)
        {
            using (var sr = new StreamReader(fileName))
            using (var csv = new CsvReader(sr, CultureInfo.InvariantCulture))
            {
                csv.Configuration.RegisterClassMap<RawUsageMap>();
                var lst = csv.GetRecords<LogUsage>().ToList();
                return lst;
            }
        }

        /// <summary>
        /// Get the url to the web service to download 
        /// the log usage file for specified month.
        /// </summary>
        public Task<Uri> GetAvailableRawUsageFilesbyMonth(DateTime month)
        {
            string mth = month.ToString("yyyy-MM-dd");
            return _ctx.RawUsageFileInfos
                .AvailableRawUsageFilesByMonth(Config.CompanyCode, mth)
                .GetValueAsync()
                .ContinueWith(t =>
                {
                    RawUsageFileInfo resp = t.Result;
                    var chunkSuffix = resp.chunkSuffix;
                    var dataLakeFileName = resp.dataLakeFileName;

                    var uri = new Uri(String.Format("{0}/DownloadRawUsageFile?companyCode={1}&month={2}&filename={3}&chunkSuffix={4}",
                        Config.ApiUrl, Config.CompanyCode, mth, dataLakeFileName, chunkSuffix));

                    return uri;
                });
        }

        /// <summary>
        /// A convenience function to get the log usage for the current month
        /// from the web service.
        /// </summary>
        /// <returns>Log usage data objects</returns>
        public Task<List<LogUsage>> GetCurrentLogUsage() =>
             GetAvailableRawUsageFilesbyMonth(DateTime.UtcNow).ContinueWith(t =>
            {
                // first call the web service to the the uri
                var uri = t.Result;

                // then download the file from that web service uri
                return ParseAvailableRawUsageFiles(uri).Result; 
            });

        #endregion

        #region ISL, Keystore, Keys, Products, Site

        public Task<Keystore> GetKeystore(string id) =>
            _ctx.Keystores.ByKey(new Dictionary<string, object> { { "id", id } })
                .Expand("keys($expand=keyQuantities)").GetValueAsync();

        /// <summary>
        /// Get all the keystores and keys for each keystore.
        /// </summary>
        public Task<List<Keystore>> GetKeystores() =>
            _ctx.Keystores.Expand("keys($expand=keyQuantities)")
                .GetAllPagesAsync()
                .ContinueWith(t => t.Result.ToList());

        /// <summary>
        /// Get more info about the Keys from a KeyStore
        /// </summary>
        /// <param name="keystoreId">ID of the KeyStore</param>
        public Task<List<Key>> GetCurrentKeys(string keystoreId)
        {
            var p = new UriOperationParameter("keystoreId", keystoreId);
            return _ctx.Keys.CreateFunctionQuery<Key>("Current",
                false, new UriOperationParameter[] { p })
                .Expand("keyQuantities($expand=components)").GetAllPagesAsync()
                .ContinueWith(t => t.Result.ToList());
        }

        public Task<List<UniqueUsageDimensions>> GetUniqueUsageDimension(DateRange dtrange)
        {
            string fdt = dtrange.FromDateString;
            string tdt = dtrange.ToDateString;
            return _ctx.UniqueUsageDimensions.ForCompany(Config.CompanyCode, fdt, tdt)
                .Expand(i => i.product)
                .Expand(i => i.licenseType)
                .Expand(i => i.keystore)
                .Expand(i => i.endUseSite)
                .GetAllPagesAsync()
                .ContinueWith(t => t.Result.ToList());
        }

        public Task<List<AnalyticsEndUseSite>> GetEndUseSites() =>
            _ctx.AnalyticsEndUseSites.ByCompany(Config.CompanyCode)
                .GetAllPagesAsync()
                .ContinueWith(t => t.Result.ToList());

        #endregion

        #region ISL, UsageDayFacts, UsageMonthFacts

        /// <summary>
        /// Get usage statistics
        /// </summary>
        public Task<List<UsageDayFact>> GetUsageConcurrentMaxConsumedByDay(DateRange dtrange) =>
            GetUsageDayFacts(dtrange, 1);

        /// <summary>
        /// Get usage statistics
        /// </summary>
        public Task<List<UsageDayFact>> GetUsagePeakQuantityUsedByDay(DateRange dtrange) =>
            GetUsageDayFacts(dtrange, 2);

        /// <summary>
        /// Get usage statistics
        /// </summary>
        public Task<List<UsageDayFact>> GetUsageTotalQuantityUsedByDay(DateRange dtrange) =>
            GetUsageDayFacts(dtrange, 3);

        /// <summary>
        /// Get usage statistics
        /// </summary>
        public Task<List<UsageDayFact>> GetUsageTotalTimeUsedByDay(DateRange dtrange) =>
            GetUsageDayFacts(dtrange, 4);

        /// <summary>
        /// Get usage statistics
        /// </summary>
        public Task<List<UsageDayFact>> GetUsageByDay(DateRange dtrange) =>
            GetUsageDayFacts(dtrange, 5);

        /// <summary>
        /// Get usage statistics
        /// </summary>
        public Task<List<UsageDayFact>> GetUsageConsumableByDay(DateRange dtrange) =>
            GetUsageDayFacts(dtrange);

        protected Task<List<UsageDayFact>> GetUsageDayFacts(DateRange dtrange, int mode = 0)
        {
            string fdt = dtrange.FromDateString;
            string tdt = dtrange.ToDateString;
            int topProds = 10;

            // build up query
            var qs = _ctx.UsageDayFacts;
            IQueryable<UsageDayFact> q = _ctx.UsageDayFacts;
            switch (mode)
            {
                case 1:
                    qs = qs.ByConcurrentMaxConsumed(
                        Config.CompanyCode, fdt, tdt, topProds);
                    break;
                case 2:
                    qs = qs.ByPeakQuantityUsed(
                        Config.CompanyCode, fdt, tdt, topProds);
                    break;
                case 3:
                    qs = qs.ByTotalQuantityUsed(
                        Config.CompanyCode, fdt, tdt, topProds);
                    break;
                case 4:
                    qs = qs.ByTotalTimeUsed(
                        Config.CompanyCode, fdt, tdt, topProds, "");
                    break;
                case 5:
                    qs = qs.ByCompany(Config.CompanyCode);
                    break;
                default:
                    qs = qs.ByConsumableTotalQuantityUsed(
                        Config.CompanyCode, fdt, tdt, topProds);
                    break;
            }
            return qs.GetAllPagesAsync().ContinueWith(t => {
                var lst = t.Result.ToList();
                if (mode == 5)
                {
                    var fdk = int.Parse(dtrange.FromDate.ToString("yyyyMMdd"));
                    var tdk = int.Parse(dtrange.ToDate.ToString("yyyyMMdd"));
                    lst = lst.Where(i => i.dateKey >= fdk && i.dateKey <= tdk).ToList();
                }
                return lst;
            });
        }

        /// <summary>
        /// Get usage statistics
        /// </summary>
        public Task<List<UsageMonthFact>> GetUsageByMonth(DateRange dtrange)
        {
            var fdk = int.Parse(dtrange.FromDate.ToString("yyyyMM"));
            var tdk = int.Parse(dtrange.ToDate.ToString("yyyyMM"));
            var qs = _ctx.UsageMonthFacts.ByCompany(Config.CompanyCode);
            return qs.Where(i => i.monthKey >= fdk && i.monthKey <= tdk).ToListAsync();
        }

        #endregion

        #region SPLM

        /// <summary>
        /// Also contain information about sites
        /// </summary>
        public Task<List<SplmServer>> GetSplmServers() =>
            _ctx.SplmServers.Where(i => i.companyCode == Config.CompanyCode).ToListAsync();

        /// <summary>
        /// Contain keys and key quantities for each product
        /// </summary>
        /// <param name="endUsesiteId"></param>
        public Task<List<SplmKey>> GetCurrentSplmKeys(string endUsesiteId) =>
            _ctx.SplmKeys
                .MostSignificant(endUsesiteId)
                .Expand(i => i.keystore)
                .Expand(i => i.keyQuantities)
                .GetAllPagesAsync()
                .ContinueWith(t => t.Result.ToList());

        #endregion

        #region Connection

        protected WebClient GetWebClient()
        {
            var wc = new System.Net.WebClient();
            wc.Headers.Set("Authorization", String.Format("Bearer {0}", _ts.GetToken().access_token));
            return wc;
        }

        #endregion

        #region Utilities

        protected DateTime? ParseDT(string val)
        {
            DateTime v;
            if (DateTime.TryParse(val, out v))
                return v;
            else return new Nullable<DateTime>();
        }

        protected int? ParseNum(string val)
        {
            int v;
            if (Int32.TryParse(val, out v))
                return v;
            else return new Nullable<int>();
        }

        protected string ParseNA(string val)
        {
            return "N/A" == val ? null : val;
        }

        #endregion
    }
}
